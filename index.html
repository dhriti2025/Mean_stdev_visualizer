<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Normal / Skew-Normal Visualizer (x, z, p + tail shading)</title>
<style>
  :root{
    --bg:#0b1220;
    --panel:#101a2c;
    --text:#e7eeff;
    --muted:rgba(231,238,255,0.75);
    --radius:18px;
  }
  *{ box-sizing:border-box; }
  body{
    margin:0;
    background: radial-gradient(1200px 800px at 20% 0%, #152645 0%, var(--bg) 55%);
    color:var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
  }
  .wrap{
    max-width: 1400px;
    margin: 18px auto;
    padding: 0 14px 24px;

    display:grid;
    grid-template-columns: minmax(320px, 380px) minmax(0, 1fr); /* critical */
    gap:16px;
    align-items:start;
  }
  .wrap > .card{ min-width:0; } /* critical */

  .card{
    background: color-mix(in srgb, var(--panel) 92%, black 8%);
    border: 1px solid rgba(255,255,255,0.10);
    border-radius: var(--radius);
    box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    overflow: hidden;
  }
  .card h2{
    margin:0;
    padding:14px 16px 10px;
    font-size:16px;
    letter-spacing:0.2px;
    border-bottom: 1px solid rgba(255,255,255,0.08);
  }

  .controls{ padding: 14px 16px 8px; display:flex; flex-direction:column; gap:12px; }
  .row{
    display:grid;
    grid-template-columns: 1fr minmax(160px, 210px);
    gap:10px;
    align-items:center;
  }
  .row label{
    font-size:13px;
    color:var(--muted);
    min-width:0;
    overflow-wrap:anywhere;
  }
  .row input, .row select{
    width:100%;
    min-width:0;
    padding:8px 10px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,0.16);
    background: rgba(0,0,0,0.20);
    color:var(--text);
    outline:none;
  }

  .sliderline{
    display:grid;
    grid-template-columns: 1fr auto;
    gap:10px;
    align-items:center;
  }
  input[type="range"]{ width:100%; min-width:0; }
  .pill{
    padding:6px 10px;
    border-radius: 999px;
    border:1px solid rgba(255,255,255,0.12);
    background: rgba(0,0,0,0.20);
    color:var(--text);
    font-variant-numeric: tabular-nums;
    font-size: 12px;
    white-space: nowrap;
  }

  .toggles{
    display:flex;
    flex-wrap:wrap;
    gap:10px 14px;
    padding: 6px 16px 14px;
    border-top: 1px solid rgba(255,255,255,0.08);
  }
  .toggles label{
    font-size:12.5px;
    color:var(--muted);
    display:flex;
    align-items:center;
    gap:8px;
    user-select:none;
  }

  .info{
    padding: 12px 16px 14px;
    border-top: 1px solid rgba(255,255,255,0.08);
    display:flex;
    flex-direction:column;
    gap:8px;
  }
  .info div{
    display:flex;
    justify-content:space-between;
    gap:12px;
    font-size:13px;
  }
  .info b{ font-weight:650; color: rgba(231,238,255,0.90); }
  .info span{
    font-variant-numeric: tabular-nums;
    overflow-wrap:anywhere;
    word-break: break-word;
    text-align:right;
  }

  .plothead{
    display:flex;
    justify-content:space-between;
    gap:12px;
    align-items:center;
    padding: 12px 16px;
    border-bottom: 1px solid rgba(255,255,255,0.08);
  }
  .plothead .small{
    color: var(--muted);
    font-size: 12px;
    min-width:0;
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
  }
  canvas{
    display:block;
    width:100%;
    height:520px;
  }
  
   @media (max-width: 900px){
  .wrap{
    grid-template-columns: 1fr;
    grid-template-areas:
      "plot"
      "inputs";
  }
  .inputs{ grid-area: inputs; }
  .plot{ grid-area: plot; }

  canvas{ height: 360px; } /* keep or adjust */
}


</style>
</head>

 <footer>
  © 2026 Dhriti Bhattacharyya · Interactive Normal Distribution visualizer
  <br>
  Licensed under CC BY–NC 4.0
<br>
  <span style="opacity:0.7; font-size:0.85em;">
    Developed with AI-assisted coding support (ChatGPT, OpenAI)
  </span>
   
</footer>

  
<body>
  <div class="wrap">

    <!-- LEFT: Inputs -->
    <div class="card inputs">
      <h2>Inputs</h2>

      <div class="controls">

        <div class="row">
          <label for="distMode">Distribution</label>
          <select id="distMode">
            <option value="normal">Normal (analytic CDF)</option>
            <option value="skew">Skew-normal (numeric CDF)</option>
          </select>
        </div>

        <div class="row">
          <label for="meanInput">Mean (μ)</label>
          <input id="meanInput" type="number" step="0.01" value="0">
        </div>
        <div class="sliderline">
          <input id="meanSlider" type="range" min="-50" max="50" step="0.01" value="0">
          <div class="pill" id="meanPill">0.00</div>
        </div>

        <div class="row">
          <label for="sdInput">Std Dev (σ)</label>
          <input id="sdInput" type="number" step="0.01" value="10">
        </div>
        <div class="sliderline">
          <input id="sdSlider" type="range" min="0.10" max="25" step="0.01" value="10">
          <div class="pill" id="sdPill">10.00</div>
        </div>

        <div class="row">
          <label for="skewInput">Skewness control (α)</label>
          <input id="skewInput" type="number" step="0.01" value="-4">
        </div>
        <div class="sliderline">
          <input id="skewSlider" type="range" min="-12" max="12" step="0.01" value="-4">
          <div class="pill" id="skewPill">-4.00</div>
        </div>

        <div class="row">
          <label for="xQueryInput">Query x</label>
          <input id="xQueryInput" type="number" step="0.01" value="0">
        </div>
        <div class="sliderline">
          <input id="xQuerySlider" type="range" min="-100" max="100" step="0.01" value="0">
          <div class="pill" id="xQueryPill">0.00</div>
        </div>

        <div class="row">
          <label for="tailMode">p-value tail</label>
          <select id="tailMode">
            <option value="left">Left-tailed: p = P(X ≤ x)</option>
            <option value="right">Right-tailed: p = P(X ≥ x)</option>
            <option value="two">Two-tailed (symmetric about μ using |x−μ|)</option>
          </select>
        </div>

      </div>

      <div class="toggles">
        <label><input id="showPdf" type="checkbox" checked> Show PDF</label>
        <label><input id="shadeTails" type="checkbox" checked> Shade p-value tail(s)</label>
        <label><input id="showQueryLine" type="checkbox" checked> Show query line</label>
      </div>

      <div class="info" id="infoBox">
        <div><b>Query x:</b> <span id="xQueryVal">–</span></div>
        <div><b>z = (x−μ)/σ:</b> <span id="zVal">–</span></div>
        <div><b>Tail mode:</b> <span id="tailModeVal">–</span></div>
        <div><b>p-value:</b> <span id="pVal">–</span></div>
        <div><b>Numeric median (plot window):</b> <span id="medianVal">–</span></div>
        <div><b>Area over plot window:</b> <span id="areaVal">–</span></div>
      </div>
    </div>

    <!-- RIGHT: Plot -->
    <div class="card plot">
      <div class="plothead">
        <div class="small">x-range fixed to [-100, 100]; μ ∈ [-50, 50], σ ≤ 25</div>
        <div class="small" id="status">Ready</div>
      </div>
      <canvas id="cv"></canvas>
    </div>
    
  </div>




  
<script>
(() => {
  // ---------- DOM ----------
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');

  const distMode = document.getElementById('distMode');

  const meanInput = document.getElementById('meanInput');
  const meanSlider = document.getElementById('meanSlider');
  const meanPill = document.getElementById('meanPill');

  const sdInput = document.getElementById('sdInput');
  const sdSlider = document.getElementById('sdSlider');
  const sdPill = document.getElementById('sdPill');

  const skewInput = document.getElementById('skewInput');
  const skewSlider = document.getElementById('skewSlider');
  const skewPill = document.getElementById('skewPill');

  const xQueryInput = document.getElementById('xQueryInput');
  const xQuerySlider = document.getElementById('xQuerySlider');
  const xQueryPill = document.getElementById('xQueryPill');

  const tailMode = document.getElementById('tailMode');

  const showPdf = document.getElementById('showPdf');
  const shadeTails = document.getElementById('shadeTails');
  const showQueryLine = document.getElementById('showQueryLine');

  const xQueryVal = document.getElementById('xQueryVal');
  const zVal = document.getElementById('zVal');
  const tailModeVal = document.getElementById('tailModeVal');
  const pVal = document.getElementById('pVal');
  const medianVal = document.getElementById('medianVal');
  const areaVal = document.getElementById('areaVal');
  const status = document.getElementById('status');

  // ---------- Helpers ----------
  function clamp(x, lo, hi){ return Math.max(lo, Math.min(hi, x)); }
  function safeNumber(val, fallback){
    const x = Number(val);
    return Number.isFinite(x) ? x : fallback;
  }

  // erf approximation (Abramowitz-Stegun)
  function erf(x){
    const sign = x < 0 ? -1 : 1;
    x = Math.abs(x);
    const a1=0.254829592, a2=-0.284496736, a3=1.421413741, a4=-1.453152027, a5=1.061405429;
    const p=0.3275911;
    const t = 1/(1+p*x);
    const y = 1 - (((((a5*t+a4)*t+a3)*t+a2)*t+a1)*t)*Math.exp(-x*x);
    return sign*y;
  }
  function normalPdf(z){ return Math.exp(-0.5*z*z) / Math.sqrt(2*Math.PI); }
  function normalCdf(z){ return 0.5 * (1 + erf(z / Math.SQRT2)); }
  function normalPdfParam(x, mu, sigma){
    const z = (x - mu) / sigma;
    return normalPdf(z) / sigma;
  }
  function normalCdfParam(x, mu, sigma){
    const z = (x - mu) / sigma;
    return normalCdf(z);
  }

  // Standard normal CDF helper for skew-normal
  function Phi(z){ return normalCdf(z); }

  // Skew-normal pdf with location xi and scale omega:
  // f(x) = (2/omega) * phi(t) * Phi(alpha * t), t=(x-xi)/omega
  function skewNormalPdf(x, xi, omega, alpha){
    const t = (x - xi) / omega;
    return (2/omega) * normalPdf(t) * Phi(alpha * t);
  }

  // Convert desired mean & sd into xi, omega for skew-normal given alpha
  // mean = xi + omega*delta*sqrt(2/pi)
  // var = omega^2 * (1 - 2*delta^2/pi)
  function skewParamsFromMeanSd(mu, sd, alpha){
    const delta = alpha / Math.sqrt(1 + alpha*alpha);
    const c = Math.sqrt(2/Math.PI) * delta;
    const denom = 1 - (2*delta*delta/Math.PI);
    const omega = sd / Math.sqrt(Math.max(denom, 1e-12));
    const xi = mu - omega * c;
    return { xi, omega, delta };
  }

  // Linear interpolation y(x) for monotone-ish arrays
  function interp1(xs, ys, x){
    if (x <= xs[0]) return ys[0];
    const n = xs.length;
    if (x >= xs[n-1]) return ys[n-1];
    // binary search
    let lo=0, hi=n-1;
    while(hi-lo>1){
      const mid = (lo+hi)>>1;
      if (xs[mid] <= x) lo = mid;
      else hi = mid;
    }
    const x0=xs[lo], x1=xs[hi];
    const y0=ys[lo], y1=ys[hi];
    const t = (x - x0) / (x1 - x0);
    return y0 + t*(y1 - y0);
  }

  function invertMonotone(xs, ys, target){
    // ys assumed nondecreasing; find x such that ys(x)=target (approx)
    const n = xs.length;
    if (target <= ys[0]) return xs[0];
    if (target >= ys[n-1]) return xs[n-1];
    let lo=0, hi=n-1;
    while(hi-lo>1){
      const mid = (lo+hi)>>1;
      if (ys[mid] <= target) lo = mid;
      else hi = mid;
    }
    const y0=ys[lo], y1=ys[hi];
    const x0=xs[lo], x1=xs[hi];
    const t = (target - y0) / (y1 - y0);
    return x0 + t*(x1 - x0);
  }

  function computeGrid(pdfFn, xMin, xMax, n=1200){
    const xs = new Array(n);
    const ys = new Array(n);
    const dx = (xMax - xMin) / (n - 1);
    let yMax = 0;

    for(let i=0;i<n;i++){
      const x = xMin + i*dx;
      const y = Math.max(0, pdfFn(x));
      xs[i] = x;
      ys[i] = y;
      if (y > yMax) yMax = y;
    }

    // area
    let area = 0;
    for(let i=0;i<n-1;i++){
      area += 0.5 * (ys[i] + ys[i+1]) * dx;
    }

    // cdf (normalized over [xMin,xMax])
    const cdf = new Array(n);
    let acc = 0;
    cdf[0] = 0;
    for(let i=0;i<n-1;i++){
      acc += 0.5 * (ys[i] + ys[i+1]) * dx;
      cdf[i+1] = acc;
    }
    const invArea = area > 0 ? 1/area : 1;
    for(let i=0;i<n;i++) cdf[i] *= invArea;

    // mode
    let modeX = xs[0], modeY = ys[0];
    for(let i=1;i<n;i++){
      if (ys[i] > modeY){ modeY = ys[i]; modeX = xs[i]; }
    }

    // median within plot window
    const med = invertMonotone(xs, cdf, 0.5);

    return { xs, ys, cdf, dx, yMax, area, modeX, median: med };
  }

  function chooseIntegrationRange(mu, sd, alpha, x){
    const K = 20 + 0.6 * Math.abs(alpha);
    const span = K * sd;
    let lo = Math.min(mu, x) - span;
    let hi = Math.max(mu, x) + span;
    lo = Math.max(lo, -2000);
    hi = Math.min(hi,  2000);
    if (hi - lo < 80){
      const mid = 0.5*(hi+lo);
      lo = mid - 40; hi = mid + 40;
    }
    return { lo, hi };
  }

  function cdfUnified(x, mu, sd, alpha, doSkew, pdfFn){
    if (!doSkew){
      return normalCdfParam(x, mu, sd); // analytic on (-∞,∞)
    }
    // numeric approx over wide window ~ (-∞,∞)
    const { lo, hi } = chooseIntegrationRange(mu, sd, alpha, x);
    const N = 12000;
    const g = computeGrid(pdfFn, lo, hi, N);
    return interp1(g.xs, g.cdf, x);
  }

  // ---------- UI sync ----------
  function syncMean(){ meanPill.textContent = safeNumber(meanInput.value,0).toFixed(2); }
  function syncSd(){ sdPill.textContent = safeNumber(sdInput.value,1).toFixed(2); }
  function syncSkew(){ skewPill.textContent = safeNumber(skewInput.value,0).toFixed(2); }
  function syncXQuery(){ xQueryPill.textContent = safeNumber(xQueryInput.value,0).toFixed(2); }

  function syncFromSliders(){
    meanInput.value = meanSlider.value;
    sdInput.value = sdSlider.value;
    skewInput.value = skewSlider.value;
    syncMean(); syncSd(); syncSkew();
    draw();
  }
  function syncXFromSlider(){
    xQueryInput.value = xQuerySlider.value;
    syncXQuery();
    draw();
  }
  function syncFromInputs(){
    meanSlider.value = clamp(safeNumber(meanInput.value,0), -50, 50);
    sdSlider.value = clamp(safeNumber(sdInput.value,10), 0.10, 25);
    skewSlider.value = clamp(safeNumber(skewInput.value,0), -12, 12);
    syncMean(); syncSd(); syncSkew();
    draw();
  }
  function syncXFromInput(){
    xQuerySlider.value = clamp(safeNumber(xQueryInput.value,0), -100, 100);
    syncXQuery();
    draw();
  }

  meanSlider.addEventListener('input', syncFromSliders);
  sdSlider.addEventListener('input', syncFromSliders);
  skewSlider.addEventListener('input', syncFromSliders);
  xQuerySlider.addEventListener('input', syncXFromSlider);

  meanInput.addEventListener('input', syncFromInputs);
  sdInput.addEventListener('input', syncFromInputs);
  skewInput.addEventListener('input', syncFromInputs);
  xQueryInput.addEventListener('input', syncXFromInput);

  distMode.addEventListener('change', draw);
  tailMode.addEventListener('change', draw);
  showPdf.addEventListener('change', draw);
  shadeTails.addEventListener('change', draw);
  showQueryLine.addEventListener('change', draw);

  function resizeCanvas(){
    const dpr = window.devicePixelRatio || 1;
    const rect = cv.getBoundingClientRect();
    const w = Math.max(300, Math.floor(rect.width));
    const h = Math.max(360, Math.floor(rect.height));
    cv.width  = Math.floor(w * dpr);
    cv.height = Math.floor(h * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  // ---------- Drawing ----------
  function draw(){
    resizeCanvas();
    ctx.clearRect(0,0,cv.width,cv.height);

    const xMin = -100, xMax = 100;

    // Read inputs
    const muDesired = clamp(safeNumber(meanInput.value, 0), -50, 50);
    const sdDesired = clamp(safeNumber(sdInput.value, 10), 0.10, 25);
    const alpha = clamp(safeNumber(skewInput.value, -4), -12, 12);
    meanInput.value = muDesired; meanSlider.value = muDesired;
    sdInput.value = sdDesired; sdSlider.value = sdDesired;
    skewInput.value = alpha; skewSlider.value = alpha;
    syncMean(); syncSd(); syncSkew();

    const doSkew = (distMode.value === "skew");

    // Define pdfFn
    let pdfFn;
    if (!doSkew){
      pdfFn = (x) => normalPdfParam(x, muDesired, sdDesired);
    } else {
      const { xi, omega } = skewParamsFromMeanSd(muDesired, sdDesired, alpha);
      pdfFn = (x) => skewNormalPdf(x, xi, omega, alpha);
    }

    // Grid for plotting (finite window)
    const grid = computeGrid(pdfFn, xMin, xMax, 2400);
    const xs = grid.xs, ys = grid.ys;
    const yMax = grid.yMax;

    // Query x
    let xq = clamp(safeNumber(xQueryInput.value, 0), xMin, xMax);
    xQueryInput.value = xq;
    xQuerySlider.value = xq;
    syncXQuery();

    // z-value (always defined vs mean/sd)
    const z = (xq - muDesired) / sdDesired;

    // Tail mode
    const mode = tailMode.value;
    tailModeVal.textContent =
      mode === "left" ? "Left-tailed" :
      mode === "right" ? "Right-tailed" : "Two-tailed (|x−μ|)";

    // p-value over (-∞,+∞) (analytic for normal, numeric for skew)
    const Fx = clamp(cdfUnified(xq, muDesired, sdDesired, alpha, doSkew, pdfFn), 0, 1);

    let pValue = 0;
    let xL = null, xR = null;

    if (mode === "left"){
      pValue = Fx;
    } else if (mode === "right"){
      pValue = 1 - Fx;
    } else {
      const d = Math.abs(xq - muDesired);
      xL = muDesired - d;
      xR = muDesired + d;

      const FL = clamp(cdfUnified(xL, muDesired, sdDesired, alpha, doSkew, pdfFn), 0, 1);
      const FR = clamp(cdfUnified(xR, muDesired, sdDesired, alpha, doSkew, pdfFn), 0, 1);
      pValue = FL + (1 - FR);
    }
    pValue = clamp(pValue, 0, 1);

    // Update readouts
    xQueryVal.textContent = xq.toFixed(4);
    zVal.textContent = Number.isFinite(z) ? z.toFixed(4) : "–";
    pVal.textContent = Number.isFinite(pValue) ? pValue.toFixed(6) : "–";
    medianVal.textContent = Number.isFinite(grid.median) ? grid.median.toFixed(4) : "–";
    areaVal.textContent = Number.isFinite(grid.area) ? grid.area.toFixed(6) : "–";

    status.textContent = doSkew ? "Skew-normal (numeric CDF)" : "Normal (analytic CDF)";

    // Plot frame
    const W = cv.getBoundingClientRect().width;
    const H = cv.getBoundingClientRect().height;

    const m = { l: 50, r: 18, t: 18, b: 42 };
    const plotW = W - m.l - m.r;
    const plotH = H - m.t - m.b;

    function xToPx(x){
      return m.l + (x - xMin) * (plotW / (xMax - xMin));
    }
    function yToPx(y){
      return m.t + plotH - (y / yMax) * plotH;
    }

    // Axes
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(m.l, m.t + plotH);
    ctx.lineTo(m.l + plotW, m.t + plotH);
    ctx.stroke();

    // x ticks
    ctx.fillStyle = "rgba(231,238,255,0.75)";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    const ticks = [-100,-50,0,50,100];
    for (const tx of ticks){
      const px = xToPx(tx);
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.beginPath();
      ctx.moveTo(px, m.t);
      ctx.lineTo(px, m.t + plotH);
      ctx.stroke();
      ctx.fillText(String(tx), px, m.t + plotH + 8);
    }

    // Tail shading (clipped to plot window)
    function shadeInterval(a,b){
      a = clamp(a, xMin, xMax);
      b = clamp(b, xMin, xMax);
      if (b <= a) return;

      ctx.fillStyle = "rgba(255,255,255,0.08)";
      ctx.beginPath();
      ctx.moveTo(xToPx(a), m.t + plotH);
      for(let i=0;i<xs.length;i++){
        const x = xs[i];
        if (x < a) continue;
        if (x > b) break;
        ctx.lineTo(xToPx(x), yToPx(ys[i]));
      }
      ctx.lineTo(xToPx(b), m.t + plotH);
      ctx.closePath();
      ctx.fill();
    }

    if (shadeTails.checked && showPdf.checked){
      if (mode === "left"){
        shadeInterval(xMin, xq);
      } else if (mode === "right"){
        shadeInterval(xq, xMax);
      } else {
        const d = Math.abs(xq - muDesired);
        const _xL = muDesired - d;
        const _xR = muDesired + d;
        shadeInterval(xMin, _xL);
        shadeInterval(_xR, xMax);

        // guide lines at xL/xR
        const xLPx = xToPx(clamp(_xL, xMin, xMax));
        const xRPx = xToPx(clamp(_xR, xMin, xMax));
        ctx.strokeStyle = "rgba(255,204,102,0.85)";
        ctx.lineWidth = 1.4;
        ctx.setLineDash([5,4]);
        ctx.beginPath(); ctx.moveTo(xLPx, m.t); ctx.lineTo(xLPx, m.t+plotH); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(xRPx, m.t); ctx.lineTo(xRPx, m.t+plotH); ctx.stroke();
        ctx.setLineDash([]);
      }
    }

    // PDF curve
    if (showPdf.checked){
      ctx.strokeStyle = "rgba(231,238,255,0.95)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(xToPx(xs[0]), yToPx(ys[0]));
      for(let i=1;i<xs.length;i++){
        ctx.lineTo(xToPx(xs[i]), yToPx(ys[i]));
      }
      ctx.stroke();
    }

    // Query x marker
    if (showQueryLine.checked){
      const xqPx = xToPx(xq);
      ctx.strokeStyle = "rgba(255,255,255,0.75)";
      ctx.lineWidth = 1.6;
      ctx.setLineDash([4,4]);
      ctx.beginPath();
      ctx.moveTo(xqPx, m.t);
      ctx.lineTo(xqPx, m.t + plotH);
      ctx.stroke();
      ctx.setLineDash([]);

      if (showPdf.checked){
        const fxq = pdfFn(xq);
        const yqPx = yToPx(fxq);
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.beginPath();
        ctx.arc(xqPx, yqPx, 4.2, 0, Math.PI*2);
        ctx.fill();
      }
    }
  }

  window.addEventListener('resize', draw);

  // initial sync + draw
  syncMean(); syncSd(); syncSkew(); syncXQuery();
  draw();
})();
</script>
</body>
</html>
