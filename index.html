<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Normal / Skew-Normal Distribution Visualizer</title>
  <style>
    :root {
      --bg: #0b0f17;
      --panel: #121a28;
      --text: #e7eefc;
      --muted: #a8b3c7;
      --grid: rgba(255,255,255,0.08);
      --accent: #7aa2ff;
      --accent2: #7dffb2;
      --warn: #ffcc66;
      --stroke: rgba(255,255,255,0.18);
      --radius: 16px;
      --pad: 14px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    body {
      margin: 0;
      background: radial-gradient(1200px 800px at 20% 10%, rgba(122,162,255,0.20), transparent 60%),
                  radial-gradient(900px 700px at 80% 20%, rgba(125,255,178,0.12), transparent 55%),
                  var(--bg);
      color: var(--text);
    }
    .wrap {
      max-width: 1100px;
      margin: 18px auto;
      padding: 0 14px 24px;
      display: grid;
      grid-template-columns: 360px 1fr;
      gap: 14px;
    }
    @media (max-width: 920px) {
      .wrap { grid-template-columns: 1fr; }
    }
    .card {
      background: color-mix(in srgb, var(--panel) 92%, black 8%);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: var(--radius);
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      overflow: hidden;
    }
    .card h2 {
      margin: 0;
      padding: 14px 16px 10px;
      font-size: 16px;
      letter-spacing: 0.2px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
    }
    .controls {
      padding: 14px 16px 16px;
      display: grid;
      gap: 12px;
    }
    .row {
      display: grid;
      grid-template-columns: 1fr 120px;
      gap: 10px;
      align-items: center;
    }
    .row label {
      font-size: 13px;
      color: var(--muted);
    }
    input[type="number"]{
      width: 100%;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(0,0,0,0.20);
      color: var(--text);
      outline: none;
    }
    input[type="number"]:focus{
      border-color: rgba(122,162,255,0.55);
      box-shadow: 0 0 0 3px rgba(122,162,255,0.15);
    }
    .sliderline{
      display: grid;
      grid-template-columns: 1fr 70px;
      gap: 10px;
      align-items: center;
    }
    input[type="range"]{
      width: 100%;
      accent-color: var(--accent);
    }
    .pill {
      font-variant-numeric: tabular-nums;
      text-align: right;
      color: var(--text);
      opacity: 0.9;
      font-size: 13px;
    }
    .toggles {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 4px;
    }
    .toggle {
      display: flex;
      gap: 10px;
      align-items: center;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.18);
      user-select: none;
    }
    .toggle input { transform: scale(1.05); }
    .toggle span { font-size: 13px; color: var(--muted); }
    .info {
      margin-top: 10px;
      padding: 12px 12px;
      border-radius: 12px;
      border: 1px dashed rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.18);
      font-size: 13px;
      color: var(--muted);
      line-height: 1.35;
    }
    .info b { color: var(--text); font-weight: 600; }
    .plot {
      padding: 0;
      display: grid;
      grid-template-rows: auto 1fr;
    }
    .plothead{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 14px 16px 10px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      gap: 10px;
      flex-wrap: wrap;
    }
    .plothead .small {
      color: var(--muted);
      font-size: 13px;
    }
    canvas {
      width: 100%;
      height: 520px;
      display:block;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.12));
    }
    .footnote{
      padding: 10px 16px 14px;
      color: rgba(231,238,252,0.70);
      font-size: 12px;
      border-top: 1px solid rgba(255,255,255,0.06);
    }
    .warn {
      color: var(--warn);
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="card">
      <h2>Inputs</h2>
      <div class="controls">
        <div class="row">
          <label for="meanInput">Mean (μ)</label>
          <input id="meanInput" type="number" step="0.01" value="0">
        </div>
        <div class="sliderline">
          <input id="meanSlider" type="range" min="-50" max="50" step="0.01" value="0">
          <div class="pill" id="meanPill">0.00</div>
        </div>

        <div class="row">
          <label for="sdInput">Std dev (σ)</label>
          <input id="sdInput" type="number" step="0.01" min="0.05" value="1">
        </div>
        <div class="sliderline">
          <input id="sdSlider" type="range" min="0.05" max="25" step="0.01" value="1">
          <div class="pill" id="sdPill">1.00</div>
        </div>

        <div class="row">
          <label for="skewInput">Skewness control (α)</label>
          <input id="skewInput" type="number" step="0.01" value="0">
        </div>
        <div class="sliderline">
          <input id="skewSlider" type="range" min="-12" max="12" step="0.01" value="0">
          <div class="pill" id="skewPill">0.00</div>
        </div>

        <div class="row">
          <label for="medianInput">Median (computed)</label>
          <input id="medianInput" type="number" step="0.0001" value="0" disabled>
        </div>

        <div class="toggles">
          <label class="toggle" title="Show the PDF curve">
            <input id="showPdf" type="checkbox" checked>
            <span>Show PDF</span>
          </label>
          <label class="toggle" title="Show vertical lines for mean & median">
            <input id="showLines" type="checkbox" checked>
            <span>Mean/Median lines</span>
          </label>
          <label class="toggle" title="Show ±1σ band (around the desired mean)">
            <input id="showSigma" type="checkbox" checked>
            <span>±1σ band</span>
          </label>
          <label class="toggle" title="Use skew-normal (α≠0). If unchecked, always use normal even if α is nonzero">
            <input id="useSkewNormal" type="checkbox" checked>
            <span>Use skew-normal</span>
          </label>
        </div>

        <div class="info" id="infoBox">
          <div><b>Model:</b> <span id="modelName">Normal</span></div>
          <div><b>PDF peak (mode):</b> <span id="modeVal">–</span></div>
          <div><b>Median:</b> <span id="medianVal">–</span></div>
          <div><b>Area check:</b> <span id="areaVal">–</span> <span id="areaWarn" class="warn"></span></div>
        </div>
      </div>
    </div>

    <div class="card plot">
      <div class="plothead">
        <div>
          <div style="font-size:16px; font-weight:600;">Distribution</div>
          <div class="small">Normal when α = 0. Skew-normal when α ≠ 0 (if enabled).</div>
        </div>
        <div class="small" id="rangeLabel">x-range: –</div>
      </div>
      <canvas id="canvas"></canvas>
      <div class="footnote">
        Tip: edit the number fields for precise values, or drag sliders for quick changes. Median is computed numerically for skew-normal.
      </div>
    </div>
  </div>

<script>
(() => {
  // ---------- Math helpers ----------
  const SQRT2 = Math.SQRT2;
  const SQRT2PI = Math.sqrt(2 * Math.PI);

  function clamp(x, lo, hi){ return Math.min(hi, Math.max(lo, x)); }

  // Abramowitz-Stegun erf approximation (good enough for visualization)
  function erf(x){
    const sign = x < 0 ? -1 : 1;
    x = Math.abs(x);
    const a1=0.254829592, a2=-0.284496736, a3=1.421413741, a4=-1.453152027, a5=1.061405429;
    const p=0.3275911;
    const t = 1/(1+p*x);
    const y = 1 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*Math.exp(-x*x);
    return sign*y;
  }

  function normalPdf(z){
    return Math.exp(-0.5*z*z) / SQRT2PI;
  }
  function normalCdf(z){
    return 0.5 * (1 + erf(z / SQRT2));
  }

  // Skew-normal pdf: f(x)= 2/ω * φ(z) * Φ(α z), z=(x-ξ)/ω
  function skewNormalPdf(x, xi, omega, alpha){
    const z = (x - xi) / omega;
    return (2/omega) * normalPdf(z) * normalCdf(alpha * z);
  }

  // For alpha=0, skew-normal reduces to normal with mean=xi, sd=omega.
  function normalPdfParam(x, mu, sigma){
    const z = (x - mu) / sigma;
    return (1/sigma) * normalPdf(z);
  }

  // Given desired mean μ and sd σ and skew shape α, compute skew-normal (ξ, ω)
  // mean = ξ + ω * δ * sqrt(2/π)
  // var  = ω^2 * (1 - 2δ^2/π)
  // δ = α / sqrt(1+α^2)
  function skewParamsFromMeanSd(mu, sd, alpha){
    if (Math.abs(alpha) < 1e-12) return { xi: mu, omega: sd, alpha: 0 };
    const delta = alpha / Math.sqrt(1 + alpha*alpha);
    const denom = Math.sqrt(Math.max(1e-12, 1 - (2*delta*delta)/Math.PI));
    const omega = sd / denom;
    const xi = mu - omega * delta * Math.sqrt(2/Math.PI);
    return { xi, omega, alpha };
  }

  // Build a grid, compute pdf values, and approximate CDF via trapezoid rule
  function computeGrid(pdfFn, xMin, xMax, n=1200){
    const xs = new Array(n);
    const ys = new Array(n);
    const dx = (xMax - xMin) / (n - 1);
    let yMax = 0;

    for(let i=0;i<n;i++){
      const x = xMin + i*dx;
      const y = pdfFn(x);
      xs[i]=x; ys[i]=y;
      if (y > yMax) yMax = y;
    }

    // area via trapezoid
    let area = 0;
    for(let i=0;i<n-1;i++){
      area += 0.5 * (ys[i] + ys[i+1]) * dx;
    }

    // cumulative (unnormalized), then normalize to 1 using computed area (helps if range is truncated)
    const cdf = new Array(n);
    let acc = 0;
    cdf[0] = 0;
    for(let i=0;i<n-1;i++){
      acc += 0.5 * (ys[i] + ys[i+1]) * dx;
      cdf[i+1] = acc;
    }
    const invArea = area > 0 ? 1/area : 1;
    for(let i=0;i<n;i++) cdf[i] *= invArea;

    // mode
    let modeX = xs[0], modeY = ys[0];
    for(let i=1;i<n;i++){
      if (ys[i] > modeY){ modeY = ys[i]; modeX = xs[i]; }
    }

    // median (solve cdf ~ 0.5)
    const med = invertMonotone(xs, cdf, 0.5);

    return { xs, ys, cdf, dx, yMax, area, modeX, median: med };
  }

  function invertMonotone(xs, ys, target){
    // assumes ys is nondecreasing
    const n = ys.length;
    if (target <= ys[0]) return xs[0];
    if (target >= ys[n-1]) return xs[n-1];
    let lo = 0, hi = n-1;
    while(hi - lo > 1){
      const mid = (lo + hi) >> 1;
      if (ys[mid] >= target) hi = mid;
      else lo = mid;
    }
    const y0 = ys[lo], y1 = ys[hi];
    const x0 = xs[lo], x1 = xs[hi];
    const t = (target - y0) / Math.max(1e-12, (y1 - y0));
    return x0 + t*(x1 - x0);
  }

  // ---------- UI elements ----------
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  const meanInput = document.getElementById('meanInput');
  const meanSlider = document.getElementById('meanSlider');
  const sdInput = document.getElementById('sdInput');
  const sdSlider = document.getElementById('sdSlider');
  const skewInput = document.getElementById('skewInput');
  const skewSlider = document.getElementById('skewSlider');

  const medianInput = document.getElementById('medianInput');

  const meanPill = document.getElementById('meanPill');
  const sdPill = document.getElementById('sdPill');
  const skewPill = document.getElementById('skewPill');

  const showPdf = document.getElementById('showPdf');
  const showLines = document.getElementById('showLines');
  const showSigma = document.getElementById('showSigma');
  const useSkewNormal = document.getElementById('useSkewNormal');

  const modelName = document.getElementById('modelName');
  const modeVal = document.getElementById('modeVal');
  const medianVal = document.getElementById('medianVal');
  const areaVal = document.getElementById('areaVal');
  const areaWarn = document.getElementById('areaWarn');
  const rangeLabel = document.getElementById('rangeLabel');

  function fmt(x, d=4){
    if (!isFinite(x)) return "–";
    const p = Math.pow(10, d);
    return (Math.round(x*p)/p).toFixed(d);
  }

  function syncPills(){
    meanPill.textContent = Number(meanInput.value).toFixed(2);
    sdPill.textContent = Number(sdInput.value).toFixed(2);
    skewPill.textContent = Number(skewInput.value).toFixed(2);
  }

  function syncFromInputs(){
    meanSlider.value = meanInput.value;
    sdSlider.value = sdInput.value;
    skewSlider.value = skewInput.value;
    syncPills();
    draw();
  }
  function syncFromSliders(){
    meanInput.value = meanSlider.value;
    sdInput.value = sdSlider.value;
    skewInput.value = skewSlider.value;
    syncPills();
    draw();
  }

  meanInput.addEventListener('input', syncFromInputs);
  sdInput.addEventListener('input', () => {
    sdInput.value = clamp(Number(sdInput.value || 1), 0.05, 1000);
    syncFromInputs();
  });
  skewInput.addEventListener('input', syncFromInputs);

  meanSlider.addEventListener('input', syncFromSliders);
  sdSlider.addEventListener('input', syncFromSliders);
  skewSlider.addEventListener('input', syncFromSliders);

  [showPdf, showLines, showSigma, useSkewNormal].forEach(el => el.addEventListener('change', draw));

  // ---------- Drawing ----------
  function resizeCanvas(){
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', () => { resizeCanvas(); draw(); });

  function draw(){
    resizeCanvas();

    const W = canvas.getBoundingClientRect().width;
    const H = canvas.getBoundingClientRect().height;

    const muDesired = Number(meanInput.value);
    const sdDesired = Math.max(0.05, Number(sdInput.value));
    const alpha = Number(skewInput.value);
    const doSkew = useSkewNormal.checked && Math.abs(alpha) > 1e-10;

    // fixed global x-range
	const xMin = -100;
	const xMax = 100;
	rangeLabel.textContent = `x-range: −100 to +100`;


    let pdfFn, label;

    if (doSkew){
      label = "Skew-normal";
      const { xi, omega } = skewParamsFromMeanSd(muDesired, sdDesired, alpha);
      pdfFn = (x) => skewNormalPdf(x, xi, omega, alpha);
    } else {
      label = "Normal";
      pdfFn = (x) => normalPdfParam(x, muDesired, sdDesired);
    }
    modelName.textContent = label;

    const grid = computeGrid(pdfFn, xMin, xMax, 1400);
    const { xs, ys, yMax, area, modeX, median } = grid;

    // update info box
    modeVal.textContent = `${fmt(modeX, 4)}`;
    medianVal.textContent = `${fmt(median, 4)}`;
    medianInput.value = (isFinite(median) ? median.toFixed(4) : "0.0000");
    areaVal.textContent = `${fmt(area, 6)}`;
    const areaErr = Math.abs(area - 1);
    areaWarn.textContent = areaErr > 0.01 ? ` (range truncation: err≈${fmt(areaErr, 4)})` : "";

    // margins
    const m = { l: 58, r: 18, t: 16, b: 42 };
    const plotW = W - m.l - m.r;
    const plotH = H - m.t - m.b;

    // background
    ctx.clearRect(0,0,W,H);

    // grid
    ctx.lineWidth = 1;
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid').trim() || "rgba(255,255,255,0.08)";

    // draw vertical gridlines (10)
    for(let i=0;i<=10;i++){
      const x = m.l + (i/10)*plotW;
      ctx.beginPath();
      ctx.moveTo(x, m.t);
      ctx.lineTo(x, m.t+plotH);
      ctx.stroke();
    }
    // horizontal gridlines (6)
    for(let i=0;i<=6;i++){
      const y = m.t + (i/6)*plotH;
      ctx.beginPath();
      ctx.moveTo(m.l, y);
      ctx.lineTo(m.l+plotW, y);
      ctx.stroke();
    }

    // axes
    ctx.strokeStyle = "rgba(255,255,255,0.28)";
    ctx.lineWidth = 1.2;
    ctx.beginPath();
    ctx.moveTo(m.l, m.t+plotH);
    ctx.lineTo(m.l+plotW, m.t+plotH);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(m.l, m.t);
    ctx.lineTo(m.l, m.t+plotH);
    ctx.stroke();

    // scaling
    const xToPx = (x) => m.l + ((x - xMin) / (xMax - xMin)) * plotW;
    const yToPx = (y) => m.t + plotH - (y / (yMax*1.08 + 1e-12)) * plotH;

    // sigma band (±1σ around desired mean)
    if (showSigma.checked){
      const x1 = xToPx(muDesired - sdDesired);
      const x2 = xToPx(muDesired + sdDesired);
      ctx.fillStyle = "rgba(122,162,255,0.12)";
      ctx.fillRect(Math.min(x1,x2), m.t, Math.abs(x2-x1), plotH);
    }

    // pdf curve
    if (showPdf.checked){
      ctx.lineWidth = 2.2;
      ctx.strokeStyle = "rgba(125,255,178,0.95)";
      ctx.beginPath();
      for(let i=0;i<xs.length;i++){
        const px = xToPx(xs[i]);
        const py = yToPx(ys[i]);
        if (i===0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.stroke();
    }

    // mean & median lines
    if (showLines.checked){
      // mean line (desired mean)
      const meanX = xToPx(muDesired);
      ctx.strokeStyle = "rgba(122,162,255,0.95)";
      ctx.lineWidth = 1.6;
      ctx.beginPath();
      ctx.moveTo(meanX, m.t);
      ctx.lineTo(meanX, m.t+plotH);
      ctx.stroke();

      // median line
      const medX = xToPx(median);
      ctx.strokeStyle = "rgba(255,204,102,0.95)";
      ctx.setLineDash([6,4]);
      ctx.lineWidth = 1.6;
      ctx.beginPath();
      ctx.moveTo(medX, m.t);
      ctx.lineTo(medX, m.t+plotH);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // labels (x-axis ticks)
    ctx.fillStyle = "rgba(231,238,252,0.88)";
    ctx.font = "12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    for(let i=0;i<=10;i++){
      const x = xMin + (i/10)*(xMax-xMin);
      const px = xToPx(x);
      ctx.fillText(x.toFixed(1), px, m.t+plotH+8);
    }

    // y-axis ticks
    ctx.textAlign = "right";
    ctx.textBaseline = "middle";
    for(let i=0;i<=6;i++){
      const y = (i/6)*(yMax*1.08);
      const py = yToPx(y);
      ctx.fillText(y.toFixed(2), m.l-8, py);
    }

    // legend
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    const lx = m.l + 8, ly = m.t + 8;
    ctx.fillStyle = "rgba(231,238,252,0.9)";
    ctx.fillText(`${label} PDF`, lx, ly);

    // small legend lines
    let yy = ly + 18;
    if (showLines.checked){
      ctx.strokeStyle = "rgba(122,162,255,0.95)";
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(lx, yy+6); ctx.lineTo(lx+22, yy+6); ctx.stroke();
      ctx.fillStyle = "rgba(231,238,252,0.82)";
      ctx.fillText(`Mean μ = ${muDesired.toFixed(3)}`, lx+28, yy);
      yy += 18;

      ctx.strokeStyle = "rgba(255,204,102,0.95)";
      ctx.setLineDash([6,4]);
      ctx.beginPath(); ctx.moveTo(lx, yy+6); ctx.lineTo(lx+22, yy+6); ctx.stroke();
      ctx.setLineDash([]);
      ctx.fillStyle = "rgba(231,238,252,0.82)";
      ctx.fillText(`Median ≈ ${isFinite(median)? median.toFixed(3): "–"}`, lx+28, yy);
      yy += 18;
    }

    if (showSigma.checked){
      ctx.fillStyle = "rgba(122,162,255,0.18)";
      ctx.fillRect(lx, yy+2, 22, 10);
      ctx.fillStyle = "rgba(231,238,252,0.82)";
      ctx.fillText(`±1σ band (σ = ${sdDesired.toFixed(3)})`, lx+28, yy);
    }
  }

  // init
  syncPills();
  draw();
})();
</script>
</body>
</html>
